"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const oss_client_1 = __importStar(require("@alicloud/oss-client")), $OSS = oss_client_1;
const openplatform20191219_1 = __importStar(require("@alicloud/openplatform20191219")), $OpenPlatform = openplatform20191219_1;
const $OSSUtil = __importStar(require("@alicloud/oss-util"));
const $FileForm = __importStar(require("@alicloud/tea-fileform"));
const number_1 = __importDefault(require("@darabonba/number"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const endpoint_util_1 = __importDefault(require("@alicloud/endpoint-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class ClassifyingRubbishRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.ClassifyingRubbishRequest = ClassifyingRubbishRequest;
class ClassifyingRubbishAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.ClassifyingRubbishAdvanceRequest = ClassifyingRubbishAdvanceRequest;
class ClassifyingRubbishResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: ClassifyingRubbishResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.ClassifyingRubbishResponseBody = ClassifyingRubbishResponseBody;
class ClassifyingRubbishResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ClassifyingRubbishResponseBody,
        };
    }
}
exports.ClassifyingRubbishResponse = ClassifyingRubbishResponse;
class DetectFruitsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.DetectFruitsRequest = DetectFruitsRequest;
class DetectFruitsAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.DetectFruitsAdvanceRequest = DetectFruitsAdvanceRequest;
class DetectFruitsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: DetectFruitsResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.DetectFruitsResponseBody = DetectFruitsResponseBody;
class DetectFruitsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DetectFruitsResponseBody,
        };
    }
}
exports.DetectFruitsResponse = DetectFruitsResponse;
class DetectImageElementsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            url: 'Url',
        };
    }
    static types() {
        return {
            url: 'string',
        };
    }
}
exports.DetectImageElementsRequest = DetectImageElementsRequest;
class DetectImageElementsAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            urlObject: 'Url',
        };
    }
    static types() {
        return {
            urlObject: 'Readable',
        };
    }
}
exports.DetectImageElementsAdvanceRequest = DetectImageElementsAdvanceRequest;
class DetectImageElementsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: DetectImageElementsResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.DetectImageElementsResponseBody = DetectImageElementsResponseBody;
class DetectImageElementsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DetectImageElementsResponseBody,
        };
    }
}
exports.DetectImageElementsResponse = DetectImageElementsResponse;
class EvaluateCertificateQualityRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
            type: 'Type',
        };
    }
    static types() {
        return {
            imageURL: 'string',
            type: 'string',
        };
    }
}
exports.EvaluateCertificateQualityRequest = EvaluateCertificateQualityRequest;
class EvaluateCertificateQualityAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
            type: 'Type',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
            type: 'string',
        };
    }
}
exports.EvaluateCertificateQualityAdvanceRequest = EvaluateCertificateQualityAdvanceRequest;
class EvaluateCertificateQualityResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: EvaluateCertificateQualityResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.EvaluateCertificateQualityResponseBody = EvaluateCertificateQualityResponseBody;
class EvaluateCertificateQualityResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: EvaluateCertificateQualityResponseBody,
        };
    }
}
exports.EvaluateCertificateQualityResponse = EvaluateCertificateQualityResponse;
class GetAsyncJobResultRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            jobId: 'JobId',
        };
    }
    static types() {
        return {
            jobId: 'string',
        };
    }
}
exports.GetAsyncJobResultRequest = GetAsyncJobResultRequest;
class GetAsyncJobResultResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: GetAsyncJobResultResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.GetAsyncJobResultResponseBody = GetAsyncJobResultResponseBody;
class GetAsyncJobResultResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetAsyncJobResultResponseBody,
        };
    }
}
exports.GetAsyncJobResultResponse = GetAsyncJobResultResponse;
class RecognizeFoodRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizeFoodRequest = RecognizeFoodRequest;
class RecognizeFoodAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizeFoodAdvanceRequest = RecognizeFoodAdvanceRequest;
class RecognizeFoodResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeFoodResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeFoodResponseBody = RecognizeFoodResponseBody;
class RecognizeFoodResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeFoodResponseBody,
        };
    }
}
exports.RecognizeFoodResponse = RecognizeFoodResponse;
class RecognizeImageColorRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            colorCount: 'ColorCount',
            url: 'Url',
        };
    }
    static types() {
        return {
            colorCount: 'number',
            url: 'string',
        };
    }
}
exports.RecognizeImageColorRequest = RecognizeImageColorRequest;
class RecognizeImageColorAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            colorCount: 'ColorCount',
            urlObject: 'Url',
        };
    }
    static types() {
        return {
            colorCount: 'number',
            urlObject: 'Readable',
        };
    }
}
exports.RecognizeImageColorAdvanceRequest = RecognizeImageColorAdvanceRequest;
class RecognizeImageColorResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeImageColorResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeImageColorResponseBody = RecognizeImageColorResponseBody;
class RecognizeImageColorResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeImageColorResponseBody,
        };
    }
}
exports.RecognizeImageColorResponse = RecognizeImageColorResponse;
class RecognizeImageStyleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            url: 'Url',
        };
    }
    static types() {
        return {
            url: 'string',
        };
    }
}
exports.RecognizeImageStyleRequest = RecognizeImageStyleRequest;
class RecognizeImageStyleAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            urlObject: 'Url',
        };
    }
    static types() {
        return {
            urlObject: 'Readable',
        };
    }
}
exports.RecognizeImageStyleAdvanceRequest = RecognizeImageStyleAdvanceRequest;
class RecognizeImageStyleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeImageStyleResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeImageStyleResponseBody = RecognizeImageStyleResponseBody;
class RecognizeImageStyleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeImageStyleResponseBody,
        };
    }
}
exports.RecognizeImageStyleResponse = RecognizeImageStyleResponse;
class RecognizeLogoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tasks: 'Tasks',
        };
    }
    static types() {
        return {
            tasks: { 'type': 'array', 'itemType': RecognizeLogoRequestTasks },
        };
    }
}
exports.RecognizeLogoRequest = RecognizeLogoRequest;
class RecognizeLogoAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tasks: 'Tasks',
        };
    }
    static types() {
        return {
            tasks: { 'type': 'array', 'itemType': RecognizeLogoAdvanceRequestTasks },
        };
    }
}
exports.RecognizeLogoAdvanceRequest = RecognizeLogoAdvanceRequest;
class RecognizeLogoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeLogoResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeLogoResponseBody = RecognizeLogoResponseBody;
class RecognizeLogoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeLogoResponseBody,
        };
    }
}
exports.RecognizeLogoResponse = RecognizeLogoResponse;
class RecognizeSceneRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizeSceneRequest = RecognizeSceneRequest;
class RecognizeSceneAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizeSceneAdvanceRequest = RecognizeSceneAdvanceRequest;
class RecognizeSceneResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeSceneResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeSceneResponseBody = RecognizeSceneResponseBody;
class RecognizeSceneResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeSceneResponseBody,
        };
    }
}
exports.RecognizeSceneResponse = RecognizeSceneResponse;
class RecognizeVehicleTypeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizeVehicleTypeRequest = RecognizeVehicleTypeRequest;
class RecognizeVehicleTypeAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizeVehicleTypeAdvanceRequest = RecognizeVehicleTypeAdvanceRequest;
class RecognizeVehicleTypeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: RecognizeVehicleTypeResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.RecognizeVehicleTypeResponseBody = RecognizeVehicleTypeResponseBody;
class RecognizeVehicleTypeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecognizeVehicleTypeResponseBody,
        };
    }
}
exports.RecognizeVehicleTypeResponse = RecognizeVehicleTypeResponse;
class TaggingAdImageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.TaggingAdImageRequest = TaggingAdImageRequest;
class TaggingAdImageAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.TaggingAdImageAdvanceRequest = TaggingAdImageAdvanceRequest;
class TaggingAdImageResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: TaggingAdImageResponseBodyData,
            message: 'string',
            requestId: 'string',
        };
    }
}
exports.TaggingAdImageResponseBody = TaggingAdImageResponseBody;
class TaggingAdImageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: TaggingAdImageResponseBody,
        };
    }
}
exports.TaggingAdImageResponse = TaggingAdImageResponse;
class TaggingImageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.TaggingImageRequest = TaggingImageRequest;
class TaggingImageAdvanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.TaggingImageAdvanceRequest = TaggingImageAdvanceRequest;
class TaggingImageResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: TaggingImageResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.TaggingImageResponseBody = TaggingImageResponseBody;
class TaggingImageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: TaggingImageResponseBody,
        };
    }
}
exports.TaggingImageResponse = TaggingImageResponse;
class ClassifyingRubbishResponseBodyDataElements extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            category: 'Category',
            categoryScore: 'CategoryScore',
            rubbish: 'Rubbish',
            rubbishScore: 'RubbishScore',
        };
    }
    static types() {
        return {
            category: 'string',
            categoryScore: 'number',
            rubbish: 'string',
            rubbishScore: 'number',
        };
    }
}
exports.ClassifyingRubbishResponseBodyDataElements = ClassifyingRubbishResponseBodyDataElements;
class ClassifyingRubbishResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            elements: 'Elements',
            sensitive: 'Sensitive',
        };
    }
    static types() {
        return {
            elements: { 'type': 'array', 'itemType': ClassifyingRubbishResponseBodyDataElements },
            sensitive: 'boolean',
        };
    }
}
exports.ClassifyingRubbishResponseBodyData = ClassifyingRubbishResponseBodyData;
class DetectFruitsResponseBodyDataElements extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            box: 'Box',
            name: 'Name',
            score: 'Score',
        };
    }
    static types() {
        return {
            box: { 'type': 'array', 'itemType': 'number' },
            name: 'string',
            score: 'number',
        };
    }
}
exports.DetectFruitsResponseBodyDataElements = DetectFruitsResponseBodyDataElements;
class DetectFruitsResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            elements: 'Elements',
        };
    }
    static types() {
        return {
            elements: { 'type': 'array', 'itemType': DetectFruitsResponseBodyDataElements },
        };
    }
}
exports.DetectFruitsResponseBodyData = DetectFruitsResponseBodyData;
class DetectImageElementsResponseBodyDataElements extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            height: 'Height',
            score: 'Score',
            type: 'Type',
            width: 'Width',
            x: 'X',
            y: 'Y',
        };
    }
    static types() {
        return {
            height: 'number',
            score: 'number',
            type: 'string',
            width: 'number',
            x: 'number',
            y: 'number',
        };
    }
}
exports.DetectImageElementsResponseBodyDataElements = DetectImageElementsResponseBodyDataElements;
class DetectImageElementsResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            elements: 'Elements',
        };
    }
    static types() {
        return {
            elements: { 'type': 'array', 'itemType': DetectImageElementsResponseBodyDataElements },
        };
    }
}
exports.DetectImageElementsResponseBodyData = DetectImageElementsResponseBodyData;
class EvaluateCertificateQualityResponseBodyDataElements extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pass: 'Pass',
            score: 'Score',
            value: 'Value',
        };
    }
    static types() {
        return {
            pass: 'string',
            score: 'string',
            value: 'string',
        };
    }
}
exports.EvaluateCertificateQualityResponseBodyDataElements = EvaluateCertificateQualityResponseBodyDataElements;
class EvaluateCertificateQualityResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            elements: 'Elements',
        };
    }
    static types() {
        return {
            elements: { 'type': 'array', 'itemType': EvaluateCertificateQualityResponseBodyDataElements },
        };
    }
}
exports.EvaluateCertificateQualityResponseBodyData = EvaluateCertificateQualityResponseBodyData;
class GetAsyncJobResultResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            errorCode: 'ErrorCode',
            errorMessage: 'ErrorMessage',
            jobId: 'JobId',
            result: 'Result',
            status: 'Status',
        };
    }
    static types() {
        return {
            errorCode: 'string',
            errorMessage: 'string',
            jobId: 'string',
            result: 'string',
            status: 'string',
        };
    }
}
exports.GetAsyncJobResultResponseBodyData = GetAsyncJobResultResponseBodyData;
class RecognizeFoodResponseBodyDataTopFives extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            calorie: 'Calorie',
            category: 'Category',
            score: 'Score',
        };
    }
    static types() {
        return {
            calorie: 'string',
            category: 'string',
            score: 'number',
        };
    }
}
exports.RecognizeFoodResponseBodyDataTopFives = RecognizeFoodResponseBodyDataTopFives;
class RecognizeFoodResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            topFives: 'TopFives',
        };
    }
    static types() {
        return {
            topFives: { 'type': 'array', 'itemType': RecognizeFoodResponseBodyDataTopFives },
        };
    }
}
exports.RecognizeFoodResponseBodyData = RecognizeFoodResponseBodyData;
class RecognizeImageColorResponseBodyDataColorTemplateList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            color: 'Color',
            label: 'Label',
            percentage: 'Percentage',
        };
    }
    static types() {
        return {
            color: 'string',
            label: 'string',
            percentage: 'number',
        };
    }
}
exports.RecognizeImageColorResponseBodyDataColorTemplateList = RecognizeImageColorResponseBodyDataColorTemplateList;
class RecognizeImageColorResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            colorTemplateList: 'ColorTemplateList',
        };
    }
    static types() {
        return {
            colorTemplateList: { 'type': 'array', 'itemType': RecognizeImageColorResponseBodyDataColorTemplateList },
        };
    }
}
exports.RecognizeImageColorResponseBodyData = RecognizeImageColorResponseBodyData;
class RecognizeImageStyleResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            styles: 'Styles',
        };
    }
    static types() {
        return {
            styles: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.RecognizeImageStyleResponseBodyData = RecognizeImageStyleResponseBodyData;
class RecognizeLogoRequestTasks extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURL: 'string',
        };
    }
}
exports.RecognizeLogoRequestTasks = RecognizeLogoRequestTasks;
class RecognizeLogoAdvanceRequestTasks extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURLObject: 'ImageURL',
        };
    }
    static types() {
        return {
            imageURLObject: 'Readable',
        };
    }
}
exports.RecognizeLogoAdvanceRequestTasks = RecognizeLogoAdvanceRequestTasks;
class RecognizeLogoResponseBodyDataElementsResultsLogosData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            h: 'H',
            name: 'Name',
            type: 'Type',
            w: 'W',
            x: 'X',
            y: 'Y',
        };
    }
    static types() {
        return {
            h: 'number',
            name: 'string',
            type: 'string',
            w: 'number',
            x: 'number',
            y: 'number',
        };
    }
}
exports.RecognizeLogoResponseBodyDataElementsResultsLogosData = RecognizeLogoResponseBodyDataElementsResultsLogosData;
class RecognizeLogoResponseBodyDataElementsResults extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            label: 'Label',
            logosData: 'LogosData',
            rate: 'Rate',
            suggestion: 'Suggestion',
        };
    }
    static types() {
        return {
            label: 'string',
            logosData: { 'type': 'array', 'itemType': RecognizeLogoResponseBodyDataElementsResultsLogosData },
            rate: 'number',
            suggestion: 'string',
        };
    }
}
exports.RecognizeLogoResponseBodyDataElementsResults = RecognizeLogoResponseBodyDataElementsResults;
class RecognizeLogoResponseBodyDataElements extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageURL: 'ImageURL',
            results: 'Results',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            imageURL: 'string',
            results: { 'type': 'array', 'itemType': RecognizeLogoResponseBodyDataElementsResults },
            taskId: 'string',
        };
    }
}
exports.RecognizeLogoResponseBodyDataElements = RecognizeLogoResponseBodyDataElements;
class RecognizeLogoResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            elements: 'Elements',
        };
    }
    static types() {
        return {
            elements: { 'type': 'array', 'itemType': RecognizeLogoResponseBodyDataElements },
        };
    }
}
exports.RecognizeLogoResponseBodyData = RecognizeLogoResponseBodyData;
class RecognizeSceneResponseBodyDataTags extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            confidence: 'Confidence',
            value: 'Value',
        };
    }
    static types() {
        return {
            confidence: 'number',
            value: 'string',
        };
    }
}
exports.RecognizeSceneResponseBodyDataTags = RecognizeSceneResponseBodyDataTags;
class RecognizeSceneResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tags: 'Tags',
        };
    }
    static types() {
        return {
            tags: { 'type': 'array', 'itemType': RecognizeSceneResponseBodyDataTags },
        };
    }
}
exports.RecognizeSceneResponseBodyData = RecognizeSceneResponseBodyData;
class RecognizeVehicleTypeResponseBodyDataElements extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'Name',
            score: 'Score',
        };
    }
    static types() {
        return {
            name: 'string',
            score: 'number',
        };
    }
}
exports.RecognizeVehicleTypeResponseBodyDataElements = RecognizeVehicleTypeResponseBodyDataElements;
class RecognizeVehicleTypeResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            elements: 'Elements',
            threshold: 'Threshold',
        };
    }
    static types() {
        return {
            elements: { 'type': 'array', 'itemType': RecognizeVehicleTypeResponseBodyDataElements },
            threshold: 'number',
        };
    }
}
exports.RecognizeVehicleTypeResponseBodyData = RecognizeVehicleTypeResponseBodyData;
class TaggingAdImageResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagInfo: 'TagInfo',
        };
    }
    static types() {
        return {
            tagInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
}
exports.TaggingAdImageResponseBodyData = TaggingAdImageResponseBodyData;
class TaggingImageResponseBodyDataTags extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            confidence: 'Confidence',
            value: 'Value',
        };
    }
    static types() {
        return {
            confidence: 'number',
            value: 'string',
        };
    }
}
exports.TaggingImageResponseBodyDataTags = TaggingImageResponseBodyDataTags;
class TaggingImageResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tags: 'Tags',
        };
    }
    static types() {
        return {
            tags: { 'type': 'array', 'itemType': TaggingImageResponseBodyDataTags },
        };
    }
}
exports.TaggingImageResponseBodyData = TaggingImageResponseBodyData;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._endpointRule = "regional";
        this.checkConfig(config);
        this._endpoint = this.getEndpoint("imagerecog", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
    }
    getEndpoint(productId, regionId, endpointRule, network, suffix, endpointMap, endpoint) {
        if (!tea_util_1.default.empty(endpoint)) {
            return endpoint;
        }
        if (!tea_util_1.default.isUnset(endpointMap) && !tea_util_1.default.empty(endpointMap[regionId])) {
            return endpointMap[regionId];
        }
        return endpoint_util_1.default.getEndpointRules(productId, regionId, endpointRule, network, suffix);
    }
    async classifyingRubbishWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ClassifyingRubbish",
            version: "2019-09-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ClassifyingRubbishResponse({}));
    }
    async classifyingRubbish(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.classifyingRubbishWithOptions(request, runtime);
    }
    async classifyingRubbishAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "imagerecog",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let classifyingRubbishReq = new ClassifyingRubbishRequest({});
        openapi_util_1.default.convert(request, classifyingRubbishReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            classifyingRubbishReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let classifyingRubbishResp = await this.classifyingRubbishWithOptions(classifyingRubbishReq, runtime);
        return classifyingRubbishResp;
    }
    async detectFruitsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DetectFruits",
            version: "2019-09-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DetectFruitsResponse({}));
    }
    async detectFruits(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.detectFruitsWithOptions(request, runtime);
    }
    async detectFruitsAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "imagerecog",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let detectFruitsReq = new DetectFruitsRequest({});
        openapi_util_1.default.convert(request, detectFruitsReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            detectFruitsReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let detectFruitsResp = await this.detectFruitsWithOptions(detectFruitsReq, runtime);
        return detectFruitsResp;
    }
    async detectImageElementsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.url)) {
            body["Url"] = request.url;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DetectImageElements",
            version: "2019-09-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DetectImageElementsResponse({}));
    }
    async detectImageElements(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.detectImageElementsWithOptions(request, runtime);
    }
    async detectImageElementsAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "imagerecog",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let detectImageElementsReq = new DetectImageElementsRequest({});
        openapi_util_1.default.convert(request, detectImageElementsReq);
        if (!tea_util_1.default.isUnset(request.urlObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.urlObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            detectImageElementsReq.url = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let detectImageElementsResp = await this.detectImageElementsWithOptions(detectImageElementsReq, runtime);
        return detectImageElementsResp;
    }
    async evaluateCertificateQualityWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            body["Type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "EvaluateCertificateQuality",
            version: "2019-09-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new EvaluateCertificateQualityResponse({}));
    }
    async evaluateCertificateQuality(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.evaluateCertificateQualityWithOptions(request, runtime);
    }
    async evaluateCertificateQualityAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "imagerecog",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let evaluateCertificateQualityReq = new EvaluateCertificateQualityRequest({});
        openapi_util_1.default.convert(request, evaluateCertificateQualityReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            evaluateCertificateQualityReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let evaluateCertificateQualityResp = await this.evaluateCertificateQualityWithOptions(evaluateCertificateQualityReq, runtime);
        return evaluateCertificateQualityResp;
    }
    async getAsyncJobResultWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetAsyncJobResult",
            version: "2019-09-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "GET",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetAsyncJobResultResponse({}));
    }
    async getAsyncJobResult(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getAsyncJobResultWithOptions(request, runtime);
    }
    async recognizeFoodWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeFood",
            version: "2019-09-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeFoodResponse({}));
    }
    async recognizeFood(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeFoodWithOptions(request, runtime);
    }
    async recognizeFoodAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "imagerecog",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeFoodReq = new RecognizeFoodRequest({});
        openapi_util_1.default.convert(request, recognizeFoodReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeFoodReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeFoodResp = await this.recognizeFoodWithOptions(recognizeFoodReq, runtime);
        return recognizeFoodResp;
    }
    async recognizeImageColorWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.colorCount)) {
            body["ColorCount"] = request.colorCount;
        }
        if (!tea_util_1.default.isUnset(request.url)) {
            body["Url"] = request.url;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeImageColor",
            version: "2019-09-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeImageColorResponse({}));
    }
    async recognizeImageColor(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeImageColorWithOptions(request, runtime);
    }
    async recognizeImageColorAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "imagerecog",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeImageColorReq = new RecognizeImageColorRequest({});
        openapi_util_1.default.convert(request, recognizeImageColorReq);
        if (!tea_util_1.default.isUnset(request.urlObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.urlObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeImageColorReq.url = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeImageColorResp = await this.recognizeImageColorWithOptions(recognizeImageColorReq, runtime);
        return recognizeImageColorResp;
    }
    async recognizeImageStyleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.url)) {
            body["Url"] = request.url;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeImageStyle",
            version: "2019-09-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeImageStyleResponse({}));
    }
    async recognizeImageStyle(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeImageStyleWithOptions(request, runtime);
    }
    async recognizeImageStyleAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "imagerecog",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeImageStyleReq = new RecognizeImageStyleRequest({});
        openapi_util_1.default.convert(request, recognizeImageStyleReq);
        if (!tea_util_1.default.isUnset(request.urlObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.urlObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeImageStyleReq.url = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeImageStyleResp = await this.recognizeImageStyleWithOptions(recognizeImageStyleReq, runtime);
        return recognizeImageStyleResp;
    }
    async recognizeLogoWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.tasks)) {
            body["Tasks"] = request.tasks;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeLogo",
            version: "2019-09-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeLogoResponse({}));
    }
    async recognizeLogo(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeLogoWithOptions(request, runtime);
    }
    async recognizeLogoAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "imagerecog",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeLogoReq = new RecognizeLogoRequest({});
        openapi_util_1.default.convert(request, recognizeLogoReq);
        if (!tea_util_1.default.isUnset(request.tasks)) {
            let i0 = 0;
            for (let item0 of request.tasks) {
                if (!tea_util_1.default.isUnset(item0.imageURLObject)) {
                    authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
                    ossConfig.accessKeyId = authResponse.body.accessKeyId;
                    ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
                    ossClient = new oss_client_1.default(ossConfig);
                    fileObj = new $FileForm.FileField({
                        filename: authResponse.body.objectKey,
                        content: item0.imageURLObject,
                        contentType: "",
                    });
                    ossHeader = new $OSS.PostObjectRequestHeader({
                        accessKeyId: authResponse.body.accessKeyId,
                        policy: authResponse.body.encodedPolicy,
                        signature: authResponse.body.signature,
                        key: authResponse.body.objectKey,
                        file: fileObj,
                        successActionStatus: "201",
                    });
                    uploadRequest = new $OSS.PostObjectRequest({
                        bucketName: authResponse.body.bucket,
                        header: ossHeader,
                    });
                    await ossClient.postObject(uploadRequest, ossRuntime);
                    let tmp = recognizeLogoReq.tasks[i0];
                    tmp.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
                    i0 = number_1.default.ltoi(number_1.default.add(number_1.default.itol(i0), number_1.default.itol(1)));
                }
            }
        }
        let recognizeLogoResp = await this.recognizeLogoWithOptions(recognizeLogoReq, runtime);
        return recognizeLogoResp;
    }
    async recognizeSceneWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeScene",
            version: "2019-09-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeSceneResponse({}));
    }
    async recognizeScene(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeSceneWithOptions(request, runtime);
    }
    async recognizeSceneAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "imagerecog",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeSceneReq = new RecognizeSceneRequest({});
        openapi_util_1.default.convert(request, recognizeSceneReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeSceneReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeSceneResp = await this.recognizeSceneWithOptions(recognizeSceneReq, runtime);
        return recognizeSceneResp;
    }
    async recognizeVehicleTypeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecognizeVehicleType",
            version: "2019-09-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecognizeVehicleTypeResponse({}));
    }
    async recognizeVehicleType(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recognizeVehicleTypeWithOptions(request, runtime);
    }
    async recognizeVehicleTypeAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "imagerecog",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let recognizeVehicleTypeReq = new RecognizeVehicleTypeRequest({});
        openapi_util_1.default.convert(request, recognizeVehicleTypeReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            recognizeVehicleTypeReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let recognizeVehicleTypeResp = await this.recognizeVehicleTypeWithOptions(recognizeVehicleTypeReq, runtime);
        return recognizeVehicleTypeResp;
    }
    async taggingAdImageWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "TaggingAdImage",
            version: "2019-09-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new TaggingAdImageResponse({}));
    }
    async taggingAdImage(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.taggingAdImageWithOptions(request, runtime);
    }
    async taggingAdImageAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "imagerecog",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let taggingAdImageReq = new TaggingAdImageRequest({});
        openapi_util_1.default.convert(request, taggingAdImageReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            taggingAdImageReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let taggingAdImageResp = await this.taggingAdImageWithOptions(taggingAdImageReq, runtime);
        return taggingAdImageResp;
    }
    async taggingImageWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageURL)) {
            body["ImageURL"] = request.imageURL;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "TaggingImage",
            version: "2019-09-30",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new TaggingImageResponse({}));
    }
    async taggingImage(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.taggingImageWithOptions(request, runtime);
    }
    async taggingImageAdvance(request, runtime) {
        // Step 0: init client
        let accessKeyId = await this._credential.getAccessKeyId();
        let accessKeySecret = await this._credential.getAccessKeySecret();
        let securityToken = await this._credential.getSecurityToken();
        let credentialType = this._credential.getType();
        let openPlatformEndpoint = this._openPlatformEndpoint;
        if (tea_util_1.default.isUnset(openPlatformEndpoint)) {
            openPlatformEndpoint = "openplatform.aliyuncs.com";
        }
        if (tea_util_1.default.isUnset(credentialType)) {
            credentialType = "access_key";
        }
        let authConfig = new $OpenApi.Config({
            accessKeyId: accessKeyId,
            accessKeySecret: accessKeySecret,
            securityToken: securityToken,
            type: credentialType,
            endpoint: openPlatformEndpoint,
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let authClient = new openplatform20191219_1.default(authConfig);
        let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
            product: "imagerecog",
            regionId: this._regionId,
        });
        let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({});
        let ossConfig = new $OSS.Config({
            accessKeySecret: accessKeySecret,
            type: "access_key",
            protocol: this._protocol,
            regionId: this._regionId,
        });
        let ossClient = null;
        let fileObj = new $FileForm.FileField({});
        let ossHeader = new $OSS.PostObjectRequestHeader({});
        let uploadRequest = new $OSS.PostObjectRequest({});
        let ossRuntime = new $OSSUtil.RuntimeOptions({});
        openapi_util_1.default.convert(runtime, ossRuntime);
        let taggingImageReq = new TaggingImageRequest({});
        openapi_util_1.default.convert(request, taggingImageReq);
        if (!tea_util_1.default.isUnset(request.imageURLObject)) {
            authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
            ossConfig.accessKeyId = authResponse.body.accessKeyId;
            ossConfig.endpoint = openapi_util_1.default.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
            ossClient = new oss_client_1.default(ossConfig);
            fileObj = new $FileForm.FileField({
                filename: authResponse.body.objectKey,
                content: request.imageURLObject,
                contentType: "",
            });
            ossHeader = new $OSS.PostObjectRequestHeader({
                accessKeyId: authResponse.body.accessKeyId,
                policy: authResponse.body.encodedPolicy,
                signature: authResponse.body.signature,
                key: authResponse.body.objectKey,
                file: fileObj,
                successActionStatus: "201",
            });
            uploadRequest = new $OSS.PostObjectRequest({
                bucketName: authResponse.body.bucket,
                header: ossHeader,
            });
            await ossClient.postObject(uploadRequest, ossRuntime);
            taggingImageReq.imageURL = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
        }
        let taggingImageResp = await this.taggingImageWithOptions(taggingImageReq, runtime);
        return taggingImageResp;
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map